// Generated by CoffeeScript 1.6.3
(function() {
  var ColorMap, Crosshairs, DataField, DataPanel, Image, Layer, LayerList, Slider, Threshold, Transform, UserInterface, View, ViewSettings, Viewer,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Viewer || (window.Viewer = {});

  /* VARIOUS HELPFUL FUNCTIONS*/


  window.typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  Array.prototype.diff = function(a) {
    return this.filter(function(i) {
      return !(a.indexOf(i) > -1);
    });
  };

  window.Viewer = Viewer = (function() {
    Viewer.AXIAL = 2;

    Viewer.CORONAL = 1;

    Viewer.SAGITTAL = 0;

    Viewer.XAXIS = 0;

    Viewer.YAXIS = 1;

    Viewer.ZAXIS = 2;

    function Viewer(layerListId, layerSettingClass, cache, options) {
      this.cache = cache != null ? cache : true;
      this.coords_ijk = Transform.atlasToImage([0, 0, 0]);
      this.coords_abc = Transform.atlasToViewer([0.0, 0.0, 0.0]);
      this.viewSettings = new ViewSettings(options);
      this.views = [];
      this.sliders = {};
      this.dataPanel = new DataPanel(this);
      this.layerList = new LayerList();
      this.userInterface = new UserInterface(this, layerListId, layerSettingClass);
      if (this.cache && (typeof amplify !== "undefined" && amplify !== null)) {
        this.cache = amplify.store;
      }
    }

    Viewer.prototype.coords_xyz = function() {
      return Transform.imageToAtlas(this.coords_ijk);
    };

    Viewer.prototype.paint = function() {
      var l, v, _i, _j, _len, _len1, _ref, _ref1;
      if (this.layerList.activeLayer) {
        this.updateDataDisplay();
      }
      _ref = this.views;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.clear();
        _ref1 = this.layerList.layers.slice(0).reverse();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          l = _ref1[_j];
          if (l.visible) {
            v.paint(l);
          }
        }
        v.drawCrosshairs();
        v.drawLabels();
      }
      return true;
    };

    Viewer.prototype.clear = function() {
      var v, _i, _len, _ref, _results;
      _ref = this.views;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v.clear());
      }
      return _results;
    };

    Viewer.prototype.resetCanvas = function() {
      var v, _i, _len, _ref, _results;
      _ref = this.views;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v.resetCanvas());
      }
      return _results;
    };

    Viewer.prototype.addView = function(element, dim, index, labels) {
      if (labels == null) {
        labels = true;
      }
      return this.views.push(new View(this, this.viewSettings, element, dim, index, labels));
    };

    Viewer.prototype.addSlider = function(name, element, orientation, min, max, value, step, dim) {
      var v, views, _i, _len, _results;
      if (dim == null) {
        dim = null;
      }
      if (name.match(/nav/)) {
        views = (function() {
          var _i, _len, _ref, _results;
          _ref = this.views;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            if (v.dim === dim) {
              _results.push(v);
            }
          }
          return _results;
        }).call(this);
        _results = [];
        for (_i = 0, _len = views.length; _i < _len; _i++) {
          v = views[_i];
          _results.push(v.addSlider(name, element, orientation, min, max, value, step));
        }
        return _results;
      } else {
        return this.userInterface.addSlider(name, element, orientation, min, max, value, step);
      }
    };

    Viewer.prototype.addDataField = function(name, element) {
      return this.dataPanel.addDataField(name, element);
    };

    Viewer.prototype.addAxisPositionField = function(name, element, dim) {
      return this.dataPanel.addAxisPositionField(name, element, dim);
    };

    Viewer.prototype.addColorSelect = function(element) {
      return this.userInterface.addColorSelect(element);
    };

    Viewer.prototype.addSignSelect = function(element) {
      return this.userInterface.addSignSelect(element);
    };

    Viewer.prototype.addSettingsCheckboxes = function(element, options) {
      var o, settings, _i, _len;
      if (options === 'standard') {
        options = ['crosshairs', 'panzoom', 'labels'];
      }
      settings = {};
      options = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = options.length; _i < _len; _i++) {
          o = options[_i];
          if (o === 'crosshairs' || o === 'panzoom' || o === 'labels') {
            _results.push(o);
          }
        }
        return _results;
      })();
      for (_i = 0, _len = options.length; _i < _len; _i++) {
        o = options[_i];
        settings[o] = this.viewSettings[o + 'Enabled'];
      }
      return this.userInterface.addSettingsCheckboxes(element, settings);
    };

    Viewer.prototype._loadImage = function(data, options) {
      var error, layer;
      options = $.extend(true, {
        colorPalette: 'red',
        sign: 'positive',
        visible: true,
        opacity: 1.0,
        cache: false,
        download: false
      }, options);
      layer = new Layer(new Image(data), options);
      this.layerList.addLayer(layer);
      try {
        if (this.cache && options.cache) {
          return amplify.store(layer.name, data);
        }
      } catch (_error) {
        error = _error;
        return "";
      }
    };

    Viewer.prototype._loadImageFromJSON = function(options) {
      var _this = this;
      return $.getJSON(options.url, function(data) {
        return _this._loadImage(data, options);
      });
    };

    Viewer.prototype._loadImageFromVolume = function(options) {
      var dfd, r, v,
        _this = this;
      dfd = $.Deferred();
      $('body').append("<div id='xtk_tmp' style='display: none;'></div>");
      r = new X.renderer3D();
      r.container = 'xtk_tmp';
      r.init();
      v = new X.volume();
      v.file = options.url + '?.nii.gz';
      r.add(v);
      r.render();
      r.onShowtime = function() {
        var data;
        r.destroy();
        data = {
          data3d: v.image,
          dims: v.dimensions
        };
        _this._loadImage(data, options);
        $('#xtk_tmp').remove();
        return dfd.resolve('Finished loading from volume');
      };
      return dfd.promise();
    };

    Viewer.prototype.loadImages = function(images, activate, paint) {
      var ajaxReqs, data, existingLayers, img, _i, _len,
        _this = this;
      if (activate == null) {
        activate = null;
      }
      if (paint == null) {
        paint = true;
      }
      /* Load one or more images. If activate is an integer, activate the layer at that 
      index. Otherwise activate the last layer in the list by default.
      */

      if (!typeIsArray(images)) {
        images = [images];
      }
      ajaxReqs = [];
      existingLayers = this.layerList.getLayerNames();
      images = (function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = images.length; _i < _len; _i++) {
          img = images[_i];
          if (_ref = img.name, __indexOf.call(existingLayers, _ref) < 0) {
            _results.push(img);
          }
        }
        return _results;
      })();
      for (_i = 0, _len = images.length; _i < _len; _i++) {
        img = images[_i];
        if ((data = img.data) || (this.cache && (data = this.cache(img.name)))) {
          this._loadImage(data, img);
        } else if (img.url.match(/\.json$/) || img.json) {
          ajaxReqs.push(this._loadImageFromJSON(img));
        } else {
          ajaxReqs.push(this._loadImageFromVolume(img));
        }
      }
      return $.when.apply($, ajaxReqs).then(function() {
        var i, order;
        order = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = images.length; _j < _len1; _j++) {
            i = images[_j];
            _results.push(i.name);
          }
          return _results;
        })();
        _this.sortLayers(order.reverse());
        _this.selectLayer(activate != null ? activate : activate = 0);
        return _this.updateUserInterface();
      });
    };

    Viewer.prototype.clearImages = function() {
      this.layerList.clearLayers();
      this.updateUserInterface();
      return this.clear();
    };

    Viewer.prototype.downloadImage = function(index) {
      var url;
      url = this.layerList.layers[index].download;
      if (url) {
        return window.location.replace(url);
      }
    };

    Viewer.prototype.selectLayer = function(index) {
      this.layerList.activateLayer(index);
      this.userInterface.updateLayerSelection(this.layerList.getActiveIndex());
      this.updateDataDisplay();
      return this.userInterface.updateComponents(this.layerList.activeLayer.getSettings());
    };

    Viewer.prototype.deleteLayer = function(target) {
      this.layerList.deleteLayer(target);
      return this.updateUserInterface();
    };

    Viewer.prototype.toggleLayer = function(index) {
      this.layerList.layers[index].toggle();
      this.userInterface.updateLayerVisibility(this.layerList.getLayerVisibilities());
      return this.paint();
    };

    Viewer.prototype.sortLayers = function(layers, paint) {
      if (paint == null) {
        paint = false;
      }
      this.layerList.sortLayers(layers);
      this.userInterface.updateLayerVisibility(this.layerList.getLayerVisibilities());
      if (paint) {
        return this.paint();
      }
    };

    Viewer.prototype.updateUserInterface = function() {
      this.userInterface.updateLayerList(this.layerList.getLayerNames(), this.layerList.getActiveIndex());
      this.userInterface.updateLayerVisibility(this.layerList.getLayerVisibilities());
      this.userInterface.updateLayerSelection(this.layerList.getActiveIndex());
      if (this.layerList.activeLayer != null) {
        this.userInterface.updateComponents(this.layerList.activeLayer.getSettings());
      }
      return this.paint();
    };

    Viewer.prototype.updateSettings = function(settings) {
      this.layerList.updateActiveLayer(settings);
      return this.paint();
    };

    Viewer.prototype.updateDataDisplay = function() {
      var activeLayer, currentCoords, currentValue, data, x, y, z, _ref;
      activeLayer = this.layerList.activeLayer;
      _ref = this.coords_ijk, x = _ref[0], y = _ref[1], z = _ref[2];
      currentValue = activeLayer.image.data[z][y][x];
      currentCoords = Transform.imageToAtlas(this.coords_ijk.slice(0)).join(', ');
      data = {
        voxelValue: currentValue,
        currentCoords: currentCoords
      };
      return this.dataPanel.update(data);
    };

    Viewer.prototype.updateViewSettings = function(options, paint) {
      if (paint == null) {
        paint = false;
      }
      this.viewSettings.updateSettings(options);
      if (paint) {
        return this.paint();
      }
    };

    Viewer.prototype.moveToViewerCoords = function(dim, cx, cy) {
      var cxyz;
      if (cy == null) {
        cy = null;
      }
      if (cy != null) {
        cxyz = [cx, cy];
        cxyz.splice(dim, 0, this.coords_abc[dim]);
      } else {
        cxyz = this.coords_abc;
        cxyz[dim] = cx;
      }
      this.coords_abc = cxyz;
      this.coords_ijk = Transform.atlasToImage(Transform.viewerToAtlas(this.coords_abc));
      return this.paint();
    };

    Viewer.prototype.moveToAtlasCoords = function(coords, paint) {
      if (paint == null) {
        paint = true;
      }
      this.coords_ijk = Transform.atlasToImage(coords);
      this.coords_abc = Transform.atlasToViewer(coords);
      if (paint) {
        return this.paint();
      }
    };

    Viewer.prototype.deleteView = function(index) {
      return this.views.splice(index, 1);
    };

    Viewer.prototype.jQueryInit = function() {
      return this.userInterface.jQueryInit();
    };

    return Viewer;

  })();

  Image = (function() {
    function Image(data) {
      var i, j, k, p, value, vec, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      _ref = data.dims, this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
      if ('data3d' in data) {
        this.min = 0;
        this.max = 0;
        this.data = [];
        for (i = _i = 0, _ref1 = this.x; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          this.data[i] = [];
          for (j = _j = 0, _ref2 = this.y; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
            this.data[i][j] = [];
            for (k = _k = 0, _ref3 = this.z; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; k = 0 <= _ref3 ? ++_k : --_k) {
              value = Math.round(data.data3d[i][j][k] * 100) / 100;
              if (value > this.max) {
                this.max = value;
              }
              if (value < this.min) {
                this.min = value;
              }
              this.data[i][j][k] = value;
            }
          }
        }
      } else if ('values' in data) {
        _ref4 = [data.max, data.min], this.max = _ref4[0], this.min = _ref4[1];
        vec = Transform.jsonToVector(data);
        this.data = Transform.vectorToVolume(vec, [this.x, this.y, this.z]);
      } else {
        this.min = 0;
        this.max = 0;
        this.data = this.empty();
      }
      if ('peaks' in data) {
        _ref5 = data.peaks;
        for (_l = 0, _len = _ref5.length; _l < _len; _l++) {
          p = _ref5[_l];
          this.addSphere(Transform.atlasToImage([p.x, p.y, p.z]), p.r != null ? p.r : p.r = 3, p.value != null ? p.value : p.value = 1);
        }
        this.max = 2;
      }
    }

    Image.prototype.empty = function() {
      var i, j, k, vol, _i, _j, _k, _ref, _ref1, _ref2;
      vol = [];
      for (i = _i = 0, _ref = this.x; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        vol[i] = [];
        for (j = _j = 0, _ref1 = this.y; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          vol[i][j] = [];
          for (k = _k = 0, _ref2 = this.z; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
            vol[i][j][k] = 0;
          }
        }
      }
      return vol;
    };

    Image.prototype.addSphere = function(coords, r, value) {
      var dist, i, j, k, x, y, z, _i, _j, _k, _ref;
      if (value == null) {
        value = 1;
      }
      if (r <= 0) {
        return;
      }
      _ref = coords.reverse(), x = _ref[0], y = _ref[1], z = _ref[2];
      if (!((x != null) && (y != null) && (z != null))) {
        return;
      }
      for (i = _i = -r; -r <= r ? _i <= r : _i >= r; i = -r <= r ? ++_i : --_i) {
        if ((x - i) < 0 || (x + i) > (this.x - 1)) {
          continue;
        }
        for (j = _j = -r; -r <= r ? _j <= r : _j >= r; j = -r <= r ? ++_j : --_j) {
          if ((y - j) < 0 || (y + j) > (this.y - 1)) {
            continue;
          }
          for (k = _k = -r; -r <= r ? _k <= r : _k >= r; k = -r <= r ? ++_k : --_k) {
            if ((z - k) < 0 || (z + k) > (this.z - 1)) {
              continue;
            }
            dist = i * i + j * j + k * k;
            if (dist < r * r) {
              this.data[i + x][j + y][k + z] = value;
            }
          }
        }
      }
      return false;
    };

    Image.prototype.resample = function(newx, newy, newz) {};

    Image.prototype.slice = function(dim, index) {
      var i, j, slice, _i, _j, _k, _ref, _ref1, _ref2;
      switch (dim) {
        case 0:
          slice = [];
          for (i = _i = 0, _ref = this.x; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            slice[i] = [];
            for (j = _j = 0, _ref1 = this.y; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              slice[i][j] = this.data[i][j][index];
            }
          }
          break;
        case 1:
          slice = [];
          for (i = _k = 0, _ref2 = this.x; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
            slice[i] = this.data[i][index];
          }
          slice;
          break;
        case 2:
          slice = this.data[index];
      }
      return slice;
    };

    Image.prototype.dims = function() {
      return [this.x, this.y, this.z];
    };

    return Image;

  })();

  Layer = (function() {
    function Layer(image, options) {
      this.image = image;
      this.options = options;
      this.name = this.options.name;
      this.sign = this.options.sign;
      this.colorMap = this.setColorMap(options.colorPalette);
      this.visible = this.options.visible;
      this.threshold = this.setThreshold(0, 0);
      this.opacity = this.options.opacity;
      this.download = this.options.download;
    }

    Layer.prototype.hide = function() {
      return this.visible = false;
    };

    Layer.prototype.show = function() {
      return this.visible = true;
    };

    Layer.prototype.toggle = function() {
      return this.visible = !this.visible;
    };

    Layer.prototype.slice = function(view, viewer) {
      var data;
      data = this.image.slice(view.dim, viewer.coords_ijk[view.dim]);
      data = this.threshold.mask(data);
      return data;
    };

    Layer.prototype.setColorMap = function(palette, steps) {
      var max, maxAbs, min;
      if (palette == null) {
        palette = null;
      }
      if (steps == null) {
        steps = null;
      }
      this.palette = palette;
      if (this.sign === 'both') {
        /* Instead of using the actual min/max range, we find the
        largest absolute value and use that as the bound for
        both signs. This preserves color maps where 0 is
        meaningful; e.g., for hot and cold, we want blues to
        be negative and reds to be positive even when
        abs(min) and abs(max) are quite different.
        BUT if min or max are 0, then implicitly fall back to
        treating mode as if it were 'positive' or 'negative'
        */

        maxAbs = Math.max(this.image.min, this.image.max);
        min = this.image.min === 0 ? 0 : -maxAbs;
        max = this.image.max === 0 ? 0 : maxAbs;
      } else {
        min = this.sign === 'positive' ? 0 : this.image.min;
        max = this.sign === 'negative' ? 0 : this.image.max;
      }
      return this.colorMap = new ColorMap(min, max, palette, steps);
    };

    Layer.prototype.setThreshold = function(negThresh, posThresh) {
      if (negThresh == null) {
        negThresh = 0;
      }
      if (posThresh == null) {
        posThresh = 0;
      }
      return this.threshold = new Threshold(negThresh, posThresh, this.sign);
    };

    Layer.prototype.update = function(settings) {
      var k, nt, pt, v;
      if ('sign' in settings) {
        this.sign = settings['sign'];
      }
      nt = 0;
      pt = 0;
      for (k in settings) {
        v = settings[k];
        switch (k) {
          case 'colorPalette':
            this.setColorMap(v);
            break;
          case 'opacity':
            this.opacity = v;
            break;
          case 'pos-threshold':
            pt = v * this.image.max;
            break;
          case 'neg-threshold':
            nt = v * this.image.min;
        }
      }
      return this.setThreshold(nt, pt, this.sign);
    };

    Layer.prototype.getSettings = function() {
      var nt, pt, settings;
      nt = this.threshold.negThresh / this.image.min;
      pt = this.threshold.posThresh / this.image.max;
      nt || (nt = 0.0);
      pt || (pt = 0.0);
      settings = {
        colorPalette: this.palette,
        sign: this.sign,
        opacity: this.opacity,
        'pos-threshold': pt,
        'neg-threshold': nt
      };
      return settings;
    };

    return Layer;

  })();

  LayerList = (function() {
    function LayerList() {
      this.clearLayers();
    }

    LayerList.prototype.addLayer = function(layer, activate) {
      if (activate == null) {
        activate = true;
      }
      this.layers.push(layer);
      if (activate) {
        return this.activateLayer(this.layers.length - 1);
      }
    };

    LayerList.prototype.deleteLayer = function(target) {
      var i, index, l, newInd;
      index = String(target).match(/^\d+$/) ? parseInt(target) : index = ((function() {
        var _i, _len, _ref, _results;
        _ref = this.layers;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          l = _ref[i];
          if (l.name === target) {
            _results.push(i);
          }
        }
        return _results;
      }).call(this))[0];
      this.layers.splice(index, 1);
      if ((this.layers.length != null) && (this.activeLayer == null)) {
        newInd = index === 0 ? 1 : index - 1;
        return this.activateLayer(newInd);
      }
    };

    LayerList.prototype.clearLayers = function() {
      this.layers = [];
      return this.activeLayer = null;
    };

    LayerList.prototype.activateLayer = function(index) {
      return this.activeLayer = this.layers[index];
    };

    LayerList.prototype.updateActiveLayer = function(settings) {
      return this.activeLayer.update(settings);
    };

    LayerList.prototype.getLayerNames = function() {
      var l;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this.layers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          _results.push(l.name);
        }
        return _results;
      }).call(this);
    };

    LayerList.prototype.getLayerVisibilities = function() {
      var l;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this.layers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          _results.push(l.visible);
        }
        return _results;
      }).call(this);
    };

    LayerList.prototype.getActiveIndex = function() {
      return this.layers.indexOf(this.activeLayer);
    };

    LayerList.prototype.getNextColor = function() {
      var free, l, palettes, used;
      used = (function() {
        var _i, _len, _ref, _results;
        _ref = this.layers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          if (l.visible) {
            _results.push(l.palette);
          }
        }
        return _results;
      }).call(this);
      palettes = Object.keys(ColorMap.PALETTES);
      free = palettes.diff(used);
      if (free.length) {
        return free[0];
      } else {
        return palettes[Math.floor(Math.random() * palettes.length)];
      }
    };

    LayerList.prototype.sortLayers = function(newOrder, destroy, newOnTop) {
      var counter, i, l, n_layers, n_new, newLayers, ni, _i, _len, _ref;
      if (destroy == null) {
        destroy = false;
      }
      if (newOnTop == null) {
        newOnTop = true;
      }
      newLayers = [];
      counter = 0;
      n_layers = this.layers.length;
      n_new = newOrder.length;
      _ref = this.layers;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        l = _ref[i];
        ni = newOrder.indexOf(l.name);
        if (ni < 0) {
          if (destroy) {
            continue;
          } else {
            ni = i;
            if (newOnTop) {
              ni += n_new;
            }
            counter += 1;
          }
        } else if (!(destroy || newOnTop)) {
          ni += counter;
        }
        newLayers[ni] = l;
      }
      return this.layers = newLayers;
    };

    return LayerList;

  })();

  Threshold = (function() {
    function Threshold(negThresh, posThresh, sign) {
      this.negThresh = negThresh;
      this.posThresh = posThresh;
      this.sign = sign != null ? sign : 'both';
    }

    Threshold.prototype.mask = function(data) {
      var i, res, _i, _ref,
        _this = this;
      if (this.posThresh === 0 && this.negThresh === 0 && this.sign === 'both') {
        return data;
      }
      res = [];
      for (i = _i = 0, _ref = data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = data[i].map(function(v) {
          if (((_this.negThresh < v && v < _this.posThresh)) || (v < 0 && _this.sign === 'positive') || (v > 0 && _this.sign === 'negative')) {
            return 0;
          } else {
            return v;
          }
        });
      }
      return res;
    };

    return Threshold;

  })();

  Transform = {
    jsonToVector: function(data) {
      var curr_inds, i, j, v, _i, _j, _k, _ref, _ref1, _ref2;
      v = new Array(data.dims[0] * data.dims[1] * data.dims[2]);
      for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        v[i] = 0;
      }
      for (i = _j = 0, _ref1 = data.values.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        curr_inds = data.indices[i];
        for (j = _k = 0, _ref2 = curr_inds.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
          v[curr_inds[j] - 1] = data.values[i];
        }
      }
      return v;
    },
    vectorToVolume: function(vec, dims) {
      var i, j, k, sliceSize, vol, x, y, z, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      vol = [];
      for (i = _i = 0, _ref = dims[0]; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        vol[i] = [];
        for (j = _j = 0, _ref1 = dims[1]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          vol[i][j] = [];
          for (k = _k = 0, _ref2 = dims[2]; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
            vol[i][j][k] = 0;
            sliceSize = dims[1] * dims[2];
          }
        }
      }
      for (i = _l = 0, _ref3 = vec.length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
        if (typeof vec[i] === undefined) {
          continue;
        }
        x = Math.floor(i / sliceSize);
        y = Math.floor((i - (x * sliceSize)) / dims[2]);
        z = i - (x * sliceSize) - (y * dims[2]);
        vol[x][y][z] = vec[i];
      }
      return vol;
    },
    transformCoordinates: function(coords, matrix, round) {
      var m, res, v;
      if (round == null) {
        round = true;
      }
      m = $M(matrix);
      coords = coords.slice(0);
      coords.push(1);
      v = $V(coords);
      res = [];
      m.x(v).each(function(e) {
        if (round) {
          e = Math.round(e);
        }
        return res.push(e);
      });
      return res;
    },
    viewerToAtlas: function(coords) {
      var matrix;
      matrix = [[180, 0, 0, -90], [0, -218, 0, 90], [0, 0, -180, 108]];
      return this.transformCoordinates(coords, matrix);
    },
    atlasToViewer: function(coords) {
      var matrix;
      matrix = [[1.0 / 180, 0, 0, 0.5], [0, -1.0 / 218, 0, 90.0 / 218], [0, 0, -1.0 / 180, 108.0 / 180]];
      return this.transformCoordinates(coords, matrix, false);
    },
    atlasToImage: function(coords) {
      var matrix;
      matrix = [[-0.5, 0, 0, 45], [0, 0.5, 0, 63], [0, 0, 0.5, 36]];
      return this.transformCoordinates(coords, matrix);
    },
    imageToAtlas: function(coords) {
      var matrix;
      matrix = [[-2, 0, 0, 90], [0, 2, 0, -126], [0, 0, 2, -72]];
      return this.transformCoordinates(coords, matrix);
    }
  };

  UserInterface = (function() {
    function UserInterface(viewer, layerListId, layerSettingClass) {
      var _this = this;
      this.viewer = viewer;
      this.layerListId = layerListId;
      this.layerSettingClass = layerSettingClass;
      this.viewSettings = this.viewer.viewSettings;
      this.sliders = {};
      $(this.layerListId).sortable({
        update: function() {
          var layers, paint;
          layers = ($('.layer_list_item').map(function() {
            return $(this).text();
          })).toArray();
          return _this.viewer.sortLayers(layers, paint = true);
        }
      });
      $(this.layerSettingClass).change(function(e) {
        return _this.settingsChanged();
      });
    }

    UserInterface.prototype.addSlider = function(name, element, orientation, min, max, value, step, dim) {
      return this.sliders[name] = new Slider(this, name, element, orientation, min, max, value, step, dim);
    };

    UserInterface.prototype.addColorSelect = function(element) {
      var p, _results;
      this.colorSelect = element;
      $(element).empty();
      _results = [];
      for (p in ColorMap.PALETTES) {
        _results.push($(element).append($('<option></option>').text(p).val(p)));
      }
      return _results;
    };

    UserInterface.prototype.addSignSelect = function(element) {
      var p, _i, _len, _ref, _results;
      this.signSelect = element;
      $(element).empty();
      _ref = ['both', 'positive', 'negative'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push($(element).append($('<option></option>').text(p).val(p)));
      }
      return _results;
    };

    UserInterface.prototype.addSettingsCheckboxes = function(element, settings) {
      var checked, s, v, validSettings,
        _this = this;
      $(element).empty();
      validSettings = {
        panzoom: 'Pan/zoom',
        crosshairs: 'Crosshairs',
        labels: 'Labels'
      };
      for (s in settings) {
        v = settings[s];
        if (s in validSettings) {
          checked = v ? ' checked' : '';
          $(element).append("<div class='checkbox_row'><input type='checkbox' class='settings_box' " + checked + " id='" + s + "'>" + validSettings[s] + "</div>");
        }
      }
      return $('.settings_box').change(function(e) {
        return _this.checkboxesChanged();
      });
    };

    UserInterface.prototype.settingsChanged = function() {
      var name, settings, slider, _ref;
      settings = {};
      _ref = this.sliders;
      for (name in _ref) {
        slider = _ref[name];
        settings[name] = $(slider.element).slider('option', 'value');
      }
      if (this.colorSelect != null) {
        settings['colorPalette'] = $(this.colorSelect).val();
      }
      if (this.signSelect != null) {
        settings['sign'] = $(this.signSelect).val();
      }
      return this.viewer.updateSettings(settings);
    };

    UserInterface.prototype.checkboxesChanged = function() {
      var id, s, settings, val, _i, _len, _ref;
      settings = {};
      _ref = $('.settings_box');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        id = $(s).attr('id');
        val = $(s).is(':checked') ? true : false;
        settings[id + 'Enabled'] = val;
      }
      return this.viewer.updateViewSettings(settings, true);
    };

    UserInterface.prototype.updateComponents = function(settings) {
      var k, v, _results;
      if ('colorPalette' in settings) {
        $(this.colorSelect).val(settings['colorPalette']);
      }
      if ('sign' in settings) {
        $(this.signSelect).val(settings['sign']);
      }
      _results = [];
      for (k in settings) {
        v = settings[k];
        if (k in this.sliders) {
          _results.push($(this.sliders[k].element).slider('option', 'value', v));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    UserInterface.prototype.updateLayerList = function(layers, selectedIndex) {
      var deletion_icon, download_icon, i, l, visibility_icon, _i, _ref,
        _this = this;
      $(this.layerListId).empty();
      for (i = _i = 0, _ref = layers.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        l = layers[i];
        visibility_icon = this.viewSettings.visibilityIconEnabled ? "<div class='visibility_icon' title='Hide/show image'><i class='icon-eye-open'></i></div>" : '';
        deletion_icon = this.viewSettings.deletionIconEnabled ? "<div class='deletion_icon' title='Delete this image'><i class='icon-trash'></i></div>" : '';
        download_icon = true ? "<div class='download_icon' title='Download this image'><i class='icon-download'></i></div>" : '';
        $(this.layerListId).append($(("<li class='layer_list_item'>" + visibility_icon + "<div class='layer_label'>") + l + ("</div>" + download_icon + deletion_icon + "</li>")));
      }
      $('.layer_label').click(function(e) {
        return _this.viewer.selectLayer($('.layer_label').index(e.target));
      });
      $('.visibility_icon').click(function(e) {
        return _this.toggleLayer($('.visibility_icon').index($(e.target).closest('div')));
      });
      $('.deletion_icon').click(function(e) {
        if (confirm("Are you sure you want to delete this image?")) {
          return _this.viewer.deleteLayer($('.deletion_icon').index($(e.target).closest('div')));
        }
      });
      $('.download_icon').click(function(e) {
        return _this.viewer.downloadImage($('.download_icon').index($(e.target).closest('div')));
      });
      return $(this.layerListId).val(selectedIndex);
    };

    UserInterface.prototype.updateLayerVisibility = function(visible) {
      var i, _i, _ref, _results;
      if (!this.viewSettings.visibilityIconEnabled) {
        return;
      }
      _results = [];
      for (i = _i = 0, _ref = visible.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (visible[i]) {
          _results.push($('.visibility_icon>i').eq(i).removeClass('icon-eye-close').addClass('icon-eye-open'));
        } else {
          _results.push($('.visibility_icon>i').eq(i).removeClass('icon-eye-open').addClass('icon-eye-close'));
        }
      }
      return _results;
    };

    UserInterface.prototype.updateLayerSelection = function(id) {
      $('.layer_label').eq(id).addClass('selected');
      return $('.layer_label').not(":eq(" + id + ")").removeClass('selected');
    };

    UserInterface.prototype.toggleLayer = function(id) {
      return this.viewer.toggleLayer(id);
    };

    return UserInterface;

  })();

  DataPanel = (function() {
    function DataPanel(viewer) {
      this.viewer = viewer;
      this.fields = {};
    }

    DataPanel.prototype.addDataField = function(name, element) {
      return this.fields[name] = new DataField(this, name, element);
    };

    DataPanel.prototype.addCoordinateFields = function(name, element) {
      var i, target, _i,
        _this = this;
      target = $(element);
      for (i = _i = 0; _i < 2; i = ++_i) {
        target.append($("<div class='axis_pos' id='axis_pos_" + axis + "'></div>"));
      }
      return $('axis_pos').change(function(e) {
        var cc, _j;
        for (i = _j = 0; _j < 2; i = ++_j) {
          cc = $("#axis_pos_" + i).val();
          _this.viewer.coords_abc[i] = Transform.atlasToViewer(cc);
          _this.viewer.coords_ijk[i] = cc;
        }
        return _this.viewer.update();
      });
    };

    DataPanel.prototype.update = function(data) {
      var i, k, pos, v, _results;
      _results = [];
      for (k in data) {
        v = data[k];
        if (k in this.fields) {
          if (k === 'currentCoordsMulti') {
            _results.push((function() {
              var _results1;
              _results1 = [];
              for (pos in v) {
                i = v[pos];
                _results1.push($("plane" + i + "_pos").text(pos));
              }
              return _results1;
            })());
          } else {
            if (k === 'currentCoords') {
              v = "[" + v + "]";
            }
            _results.push($(this.fields[k].element).text(v));
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return DataPanel;

  })();

  ViewSettings = (function() {
    /* Stores any settings common to all views--e.g., crosshair preferences,
    dragging/zooming, etc. Individual views can override these settings if view-specific
    options are desired.
    */

    function ViewSettings(options) {
      this.settings = {
        panzoomEnabled: true,
        crosshairsEnabled: true,
        crosshairsWidth: 1,
        crosshairsColor: 'lime',
        labelsEnabled: true,
        visibilityIconEnabled: true,
        deletionIconEnabled: true
      };
      this.updateSettings(options);
    }

    ViewSettings.prototype.updateSettings = function(options) {
      var k, v, _ref;
      $.extend(this.settings, options);
      _ref = this.settings;
      for (k in _ref) {
        v = _ref[k];
        this[k] = v;
      }
      return this.crosshairs = new Crosshairs(this.crosshairsEnabled, this.crosshairsColor, this.crosshairsWidth);
    };

    return ViewSettings;

  })();

  View = (function() {
    function View(viewer, viewSettings, element, dim, labels, slider) {
      this.viewer = viewer;
      this.viewSettings = viewSettings;
      this.element = element;
      this.dim = dim;
      this.labels = labels != null ? labels : true;
      this.slider = slider != null ? slider : null;
      this._handleScroll = __bind(this._handleScroll, this);
      this._zoom = __bind(this._zoom, this);
      this._canvasClick = __bind(this._canvasClick, this);
      this.resetCanvas();
      this._jQueryInit();
    }

    View.prototype.addSlider = function(name, element, orientation, min, max, value, step, dim) {
      return this.slider = new Slider(this, name, element, orientation, min, max, value, step, dim);
    };

    View.prototype.clear = function() {
      var currentState;
      currentState = $.extend(true, {}, this.context.getTransform());
      this.context.reset();
      this.context.fillStyle = 'black';
      this.context.fillRect(0, 0, this.width, this.height);
      return this.context.setTransformFromArray(currentState);
    };

    View.prototype.resetCanvas = function() {
      this.canvas = $(this.element).find('canvas');
      this.width = this.canvas.width();
      this.height = this.canvas.height();
      this.context = this.canvas[0].getContext("2d");
      trackTransforms(this.context);
      this.lastX = this.width / 2;
      this.lastY = this.height / 2;
      this.dragStart = void 0;
      this.scaleFactor = 1.1;
      return this.clear();
    };

    View.prototype.paint = function(layer) {
      var col, cols, data, dims, fuzz, i, img, j, val, xCell, xp, yCell, yp, _i, _j, _ref, _ref1;
      if (this.width === 0) {
        this.resetCanvas();
      }
      data = layer.slice(this, this.viewer);
      cols = layer.colorMap.map(data);
      img = layer.image;
      dims = [[img.y, img.z], [img.x, img.z], [img.x, img.y]];
      xCell = this.width / dims[this.dim][0];
      yCell = this.height / dims[this.dim][1];
      this.xCell = xCell;
      this.yCell = yCell;
      fuzz = 0.5;
      this.context.globalAlpha = layer.opacity;
      this.context.lineWidth = 1;
      for (i = _i = 0, _ref = dims[this.dim][1]; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = dims[this.dim][0]; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          if (typeof data[i][j] === undefined | data[i][j] === 0) {
            continue;
          }
          xp = this.width - (j + 1) * xCell;
          yp = this.height - (i + 1) * yCell;
          col = cols[i][j];
          this.context.fillStyle = col;
          this.context.fillRect(xp, yp, xCell + fuzz, yCell + fuzz);
        }
      }
      this.context.globalAlpha = 1.0;
      if (this.slider != null) {
        val = this.viewer.coords_abc[this.dim];
        if (this.dim !== Viewer.XAXIS) {
          val = 1 - val;
        }
        return $(this.slider.element).slider('option', 'value', val);
      }
    };

    View.prototype.drawCrosshairs = function() {
      var ch, xPos, yPos;
      ch = this.viewSettings.crosshairs;
      if (!ch.visible) {
        return;
      }
      this.context.fillStyle = ch.color;
      xPos = this.viewer.coords_abc[[1, 0, 0][this.dim]] * this.width;
      yPos = this.viewer.coords_abc[[2, 2, 1][this.dim]] * this.height;
      this.context.fillRect(0, yPos - ch.width / 2, this.width, ch.width);
      return this.context.fillRect(xPos - ch.width / 2, 0, ch.width, this.height);
    };

    View.prototype.drawLabels = function() {
      var fontSize, planePos, planeText;
      if (!this.viewSettings.labelsEnabled) {
        return;
      }
      fontSize = Math.round(this.height / 15);
      this.context.fillStyle = 'white';
      this.context.font = "" + fontSize + "px Helvetica";
      this.context.textAlign = 'left';
      this.context.textBaseline = 'middle';
      planePos = this.viewer.coords_xyz()[this.dim];
      if (planePos > 0) {
        planePos = '+' + planePos;
      }
      planeText = ['x', 'y', 'z'][this.dim] + ' = ' + planePos;
      this.context.fillText(planeText, 0.03 * this.width, 0.95 * this.height);
      this.context.textAlign = 'center';
      switch (this.dim) {
        case 0:
          this.context.fillText('A', 0.05 * this.width, 0.5 * this.height);
          return this.context.fillText('P', 0.95 * this.width, 0.5 * this.height);
        case 1:
          this.context.fillText('D', 0.95 * this.width, 0.05 * this.height);
          return this.context.fillText('V', 0.95 * this.width, 0.95 * this.height);
        case 2:
          this.context.fillText('L', 0.05 * this.width, 0.05 * this.height);
          return this.context.fillText('R', 0.95 * this.width, 0.05 * this.height);
      }
    };

    View.prototype.navSlideChange = function(value) {
      if (this.dim !== Viewer.XAXIS) {
        value = 1 - value;
      }
      return this.viewer.moveToViewerCoords(this.dim, value);
    };

    View.prototype._snapToGrid = function(x, y) {
      var dims, xVoxSize, yVoxSize;
      dims = [91, 109, 91];
      dims.splice(this.dim, 1);
      xVoxSize = 1 / dims[0];
      yVoxSize = 1 / dims[1];
      x = (Math.floor(x / xVoxSize) + 0.5) * xVoxSize;
      y = (Math.floor(y / yVoxSize) + 0.5) * yVoxSize;
      return {
        x: x,
        y: y
      };
    };

    View.prototype._jQueryInit = function() {
      var canvas,
        _this = this;
      canvas = $(this.element).find('canvas');
      canvas.click(this._canvasClick);
      canvas.mousedown(function(evt) {
        document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect = "none";
        _this.lastX = evt.offsetX || (evt.pageX - canvas.offsetLeft);
        _this.lastY = evt.offsetY || (evt.pageY - canvas.offsetTop);
        return _this.dragStart = _this.context.transformedPoint(_this.lastX, _this.lastY);
      });
      canvas.mousemove(function(evt) {
        var pt;
        if (!_this.viewSettings.panzoomEnabled) {
          return;
        }
        _this.lastX = evt.offsetX || (evt.pageX - canvas.offsetLeft);
        _this.lastY = evt.offsetY || (evt.pageY - canvas.offsetTop);
        if (_this.dragStart) {
          pt = _this.context.transformedPoint(_this.lastX, _this.lastY);
          _this.context.translate(pt.x - _this.dragStart.x, pt.y - _this.dragStart.y);
          return _this.viewer.paint();
        }
      });
      canvas.mouseup(function(evt) {
        return _this.dragStart = null;
      });
      canvas.on("DOMMouseScroll", this._handleScroll);
      return canvas.on("mousewheel", this._handleScroll);
    };

    View.prototype._canvasClick = function(e) {
      var cx, cy, pt;
      $(this.viewer).trigger('beforeClick');
      pt = this.context.transformedPoint(e.offsetX, e.offsetY);
      cx = pt.x / this.width;
      cy = pt.y / this.height;
      pt = this._snapToGrid(cx, cy);
      this.viewer.moveToViewerCoords(this.dim, pt.x, pt.y);
      return $(this.viewer).trigger('afterClick');
    };

    View.prototype._zoom = function(clicks) {
      var factor, pt;
      if (!this.viewSettings.panzoomEnabled) {
        return;
      }
      pt = this.context.transformedPoint(this.lastX, this.lastY);
      this.context.translate(pt.x, pt.y);
      factor = Math.pow(this.scaleFactor, clicks);
      this.context.scale(factor, factor);
      this.context.translate(-pt.x, -pt.y);
      return this.viewer.paint();
    };

    View.prototype._handleScroll = function(evt) {
      var delta, oe;
      oe = evt.originalEvent;
      delta = (oe.wheelDelta ? oe.wheelDelta / 40 : (oe.detail ? -oe.detail : 0));
      if (delta) {
        this._zoom(delta);
      }
      return evt.preventDefault() && false;
    };

    return View;

  })();

  Crosshairs = (function() {
    function Crosshairs(visible, color, width) {
      this.visible = visible != null ? visible : true;
      this.color = color != null ? color : 'lime';
      this.width = width != null ? width : 1;
    }

    return Crosshairs;

  })();

  ColorMap = (function() {
    var basic, col, _i, _len;

    ColorMap.PALETTES = {
      grayscale: ['#000000', '#303030', 'gray', 'silver', 'white']
    };

    basic = ['red', 'green', 'blue', 'yellow', 'purple', 'lime', 'aqua', 'navy'];

    for (_i = 0, _len = basic.length; _i < _len; _i++) {
      col = basic[_i];
      ColorMap.PALETTES[col] = ['black', col, 'white'];
    }

    $.extend(ColorMap.PALETTES, {
      'intense red-blue': ['#053061', '#2166AC', '#4393C3', '#F7F7F7', '#D6604D', '#B2182B', '#67001F'],
      'red-yellow-blue': ['#313695', '#4575B4', '#74ADD1', '#FFFFBF', '#F46D43', '#D73027', '#A50026'],
      'brown-teal': ['#003C30', '#01665E', '#35978F', '#F5F5F5', '#BF812D', '#8C510A', '#543005']
    });

    function ColorMap(min, max, palette, steps) {
      this.min = min;
      this.max = max;
      this.palette = palette != null ? palette : 'hot and cold';
      this.steps = steps != null ? steps : 40;
      this.range = this.max - this.min;
      this.colors = this.setColors(ColorMap.PALETTES[this.palette]);
    }

    ColorMap.prototype.map = function(data) {
      var i, res, _j, _ref,
        _this = this;
      res = [];
      for (i = _j = 0, _ref = data.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        res[i] = data[i].map(function(v) {
          return _this.colors[Math.floor(((v - _this.min) / _this.range) * _this.steps)];
        });
      }
      return res;
    };

    ColorMap.prototype.setColors = function(colors) {
      var i, rainbow, _j, _ref;
      rainbow = new Rainbow();
      rainbow.setNumberRange(1, this.steps);
      rainbow.setSpectrum.apply(null, colors);
      colors = [];
      for (i = _j = 1, _ref = this.steps; 1 <= _ref ? _j < _ref : _j > _ref; i = 1 <= _ref ? ++_j : --_j) {
        colors.push(rainbow.colourAt(i));
      }
      return colors.map(function(c) {
        return "#" + c;
      });
    };

    return ColorMap;

  })();

  Slider = (function() {
    function Slider(container, name, element, orientation, min, max, value, step) {
      this.container = container;
      this.name = name;
      this.element = element;
      this.orientation = orientation;
      this.min = min;
      this.max = max;
      this.value = value;
      this.step = step;
      this.change = __bind(this.change, this);
      this.range = this.name.match(/threshold/g) ? 'max' : this.name.match(/nav/g) ? false : 'min';
      this._jQueryInit();
    }

    Slider.prototype.change = function(e, ui) {
      if (this.name.match(/nav/g)) {
        this.container.navSlideChange(ui.value);
      } else {
        this.container.settingsChanged(e);
      }
      return e.stopPropagation();
    };

    Slider.prototype._jQueryInit = function() {
      return $(this.element).slider({
        orientation: this.orientation,
        range: this.range,
        min: this.min,
        max: this.max,
        step: this.step,
        slide: this.change,
        value: this.value
      });
    };

    return Slider;

  })();

  DataField = (function() {
    function DataField(panel, name, element) {
      this.panel = panel;
      this.name = name;
      this.element = element;
    }

    return DataField;

  })();

}).call(this);
